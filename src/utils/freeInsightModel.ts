import type { EnhancedComparisonResult, AIInsight, MetricDiff } from '../types';
import { computeImpact } from './compare';

// Lightweight heuristic "free LLM" style generator (no external keys)
export function generateFreeInsights(result: EnhancedComparisonResult): EnhancedComparisonResult {
  const diffs = result.diffs || [];
  const impact = computeImpact(result);
  const insights: AIInsight[] = [];

  // Top regressions
  const worst = [...diffs]
    .filter(d => d.trend === 'worse' && typeof d.pct === 'number')
    .sort((a,b)=> (Math.abs(b.pct || 0) - Math.abs(a.pct || 0)))
    .slice(0,3);
  if (worst.length) {
    insights.push({
      type: 'anomaly',
      severity: worst.length && Math.abs(worst[0].pct || 0) > 50 ? 'high' : 'medium',
      confidence: 0.75,
      title: 'Key Regressions Detected',
      description: worst.map(w => `${w.label} ${fmt(w.baseline)} â†’ ${fmt(w.current)} (${fmtPct(w.pct)}%)`).join('; '),
      actionable_steps: [
        'Validate recent deployments affecting these metrics',
        'Check logs & traces around regression time window',
        'Prioritize highest % impact first'
      ],
      affected_metrics: worst.map(w=>w.key)
    });
  }

  // Top improvements
  const best = [...diffs]
    .filter(d => d.trend === 'improved' && typeof d.pct === 'number')
    .sort((a,b)=> (Math.abs(b.pct || 0) - Math.abs(a.pct || 0)))
    .slice(0,3);
  if (best.length) {
    insights.push({
      type: 'suggestion',
      severity: 'low',
      confidence: 0.7,
      title: 'Notable Improvements',
      description: best.map(w => `${w.label} improved (${fmtPct(w.pct)}%)`).join('; '),
      actionable_steps: [
        'Document what drove these wins',
        'Consider replicating optimization pattern elsewhere'
      ],
      affected_metrics: best.map(w=>w.key)
    });
  }

  // Latency focus
  const latency = findMetric(diffs, /(latency|ttfb|response|load|lcp|fcp)/i);
  if (latency && typeof latency.pct === 'number') {
    insights.push({
      type: 'explanation',
      severity: latency.trend === 'improved' ? 'low' : 'medium',
      confidence: 0.65,
      title: `Latency ${latency.trend === 'improved' ? 'Improved' : 'Changed'}`,
      description: `${latency.label} change ${fmt(latency.baseline)} â†’ ${fmt(latency.current)} (${fmtPct(latency.pct)}%). Focus on reducing long tail if p95 still high.`,
      actionable_steps: [
        'Profile slow endpoints',
        'Eliminate blocking resources',
        'Add caching / CDN where applicable'
      ],
      affected_metrics: [latency.key]
    });
  }

  // Overall assessment
  insights.push({
    type: 'explanation',
    severity: impact.currentOverallBetter ? 'low' : 'medium',
    confidence: 0.6,
    title: 'Overall Assessment',
    description: impact.currentOverallBetter
      ? `Overall trend positive. Avg gain ${fmtPct(impact.avgPctImprovement)}%. ${impact.topImproved.length} key improvements outweigh regressions.`
      : `Mixed / negative trend. Investigate regressions before deploying widely. Net improvements insufficient to offset losses.` ,
    actionable_steps: impact.currentOverallBetter ? [
      'Promote successful optimization patterns',
      'Set new baseline once validated in production'
    ] : [
      'Triage worst regression first',
      'Add temporary guards / roll back risky change',
      'Re-run after fixes'
    ],
    affected_metrics: []
  });

  return { ...result, aiInsights: insights, explanation: 'Generated by local free insight engine (no external API).' };
}

function fmt(v: any) { return v === null || v === undefined ? 'â€”' : String(Math.round((v as number)*100)/100); }
function fmtPct(v: any) { return v === null || v === undefined ? 'â€”' : (Math.round((v as number)*10)/10); }
function findMetric(diffs: MetricDiff[], pattern: RegExp) { return diffs.find(d=> pattern.test(d.key) || pattern.test(d.label)); }
